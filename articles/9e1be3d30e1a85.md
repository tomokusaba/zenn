---
title: "GitHub CopilotでBlazor SignalRチャットアプリをWCAG 2.2 AA対応してみた"
emoji: "♿"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Blazor", "accessibility", "WCAG", "GitHubCopilot", "csharp"]
published: false
---

# はじめに

これまでのアクセシビリティシリーズでは、概念・設計指針から始まり、Fluent UI Blazorでの実装、CI/CDでの自動検査と段階的にテーマを掘り下げてきました📚

1. [Webアクセシビリティは"もしも"に備える設計](https://qiita.com/tomokusaba/items/9b88360daa685accb33a) ― 概念・設計指針編
2. [Fluent UI Blazorで実現するWebアクセシビリティ対応](https://zenn.dev/tomokusaba/articles/fce3b0419c9568) ― Fluent UI Blazor 実装編
3. [WebアクセシビリティをCI/CDで担保する](https://zenn.dev/tomokusaba/articles/035e696351e16d) ― axe DevTools × Playwright C# 実践ガイド

第1回では「誰もが突然アクセス能力を失う可能性がある」という前提のもと、WCAG 2.2の概要や日本の法的背景（障害者差別解消法による合理的配慮の義務化）、支援技術の種類と特徴について体系的に整理しました。第2回では、MicrosoftのFluent UIが設計段階からアクセシビリティをどのように組み込んでいるかをFluent UI Blazorコンポーネントの観点から解説し、第3回ではPlaywright C#とaxe-coreを使ったアクセシビリティの自動テストをGitHub ActionsのCI/CDパイプラインに組み込む方法を実装しました📖

今回はシリーズの総まとめとして、**アクセシビリティ対応がなされていない既存のアプリケーションに対して、GitHub Copilotの支援のもとでWCAG 2.2 AA準拠を目指す**という実践記事です🎯

## 題材とする既存アプリケーション

題材は、.NETラボ 2022年2月の勉強会で発表した**Blazor + SignalRによるリアルタイムチャットアプリ「あびや」**です。.NETラボは月1回開催されている.NET技術を中心とした勉強会で、このときはBlazorにおけるSignalRの活用方法をデモとともに紹介しました💬

アプリケーションは当初シンプルなテキストチャットとして開発されましたが、その後大幅に機能が追加され、現在はフロントエンドにBlazor Interactive Auto（初回はServer、以降はWebAssemblyに切り替わるレンダリングモード）、リアルタイム双方向通信にASP.NET Core SignalR、認証にASP.NET Core Identity + JWT、UIにFluent UI Blazorを採用しています。Azure OpenAI（Microsoft.Extensions.AI）を活用したAIキャラクター（ほのか・みずき）とのチャット機能、おさいふ（仮想通貨）システム、アイコン設定、ダークモード切替なども備えた多機能なアプリケーションです🔌

本シリーズの第2回「Fluent UI Blazorで実現するWebアクセシビリティ対応」で取り上げたとおり、UIコンポーネントは既にFluent UI Blazorへ移行されています。`MainLayout.razor`では`FluentLayout`・`FluentHeader`・`FluentBodyContent`によるレイアウト構造が、`NavMenu.razor`では`FluentAppBar`によるナビゲーションが構築されており、Fluent UIが提供する基本的なアクセシビリティ機能（キーボードナビゲーション、デザイントークンによるコントラスト管理など）は活用できる状態にあります🏗️

しかし、Fluent UIコンポーネントが自動的に提供するアクセシビリティ機能だけでは、WCAG 2.2 AAの全達成基準をカバーすることはできません。チャットメッセージ一覧のようなカスタムコンテンツ領域に対する`aria-live`の設定、各ボタンやリンクへの明示的な`AriaLabel`の付与、AIキャラクターの絵文字への`role="img"`と代替テキストの設定、フォーカス管理の最適化など、アプリケーション固有のコンテキストに応じた対応が不足していました🧐

このアプリに対して**GitHub Copilot**を活用し、不足しているアクセシビリティ対応を補完して**WCAG 2.2 AA**準拠を目指します。具体的には、GitHub Copilotへのシンプルなプロンプトだけでどの程度の対応が可能か、そしてその後にLighthouseによる自動検査でどのような問題が残り、どのように解消されるかを記録します🤖

# GitHub Copilotによるアクセシビリティ対応

## シンプルなプロンプトから始める

今回のアプローチで意図的に選択したのは、**可能な限りシンプルなプロンプトで始める**という方針です。GitHub Copilotに対して投げたプロンプトは以下の1行のみでした🤖

```
このBlazorチャットアプリをWCAG 2.2 AAに対応してください。
```

WCAG 2.2 AAのどの達成基準を優先するか、どのHTML要素を修正すべきか、ARIA属性をどこに追加するかといった詳細な指示は一切行っていません。この方針を採った理由は2つあります🧪

第一に、アクセシビリティ対応は達成基準が55項目（レベルA: 30 + レベルAA: 25）にわたるため、すべてを指示として網羅すること自体が現実的ではありません。実務においても、WCAGの全基準を暗記しているエンジニアは少数であり、「WCAGに準拠してほしい」という粒度のリクエストが実際のプロジェクトでは一般的です📏

第二に、GitHub Copilotが持つWCAGに関する知識の範囲と精度を確認したいという検証的な意図がありました。どこまで自律的に問題を特定し、適切な修正を施せるのかを測るうえで、指示をミニマルにすることが重要でした🔍

## GitHub Copilotが行った修正

GitHub Copilotはこのシンプルなプロンプトに対して、コードベース全体を走査し、大きく4つの観点から修正を提案・実施しました。以下、それぞれの修正内容とその技術的背景を詳しく見ていきます🔧

### セマンティクス構造の強化

最初に着手されたのがセマンティクス構造の見直しです🏗️

本アプリケーションは既にFluent UI Blazorコンポーネントを採用しており、`FluentLayout`・`FluentHeader`・`FluentBodyContent`によるレイアウト構造や、`FluentAppBar`によるナビゲーション構造は構築されています。Fluent UI Blazorコンポーネントは内部的にセマンティックなHTML要素をレンダリングするため、スクリーンリーダーにとって一定のランドマーク構造は提供されていました🧭

しかし、GitHub Copilotはここから更に踏み込み、Fluent UIコンポーネントが自動的にはカバーしない箇所を補強しました。具体的には、`MainLayout.razor`の`FluentHeader`への`role="banner"`の明示的な付与、`NavMenu.razor`の`FluentAppBar`への`aria-label="メインメニュー"`と`role="navigation"`の追加、`FluentBodyContent`への`role="main"`の設定です。Fluent UIコンポーネントが内部的にセマンティックなHTMLを出力する場合でも、WAI-ARIAのランドマークロールを明示的に設定しておくことで、支援技術がページ構造を確実に認識できるようになります📐

あわせて、`FluentLabel Typo="Typography.PageTitle"`による見出しの設定が確認・追加されました。見出しの階層構造が正しく設定されていると、スクリーンリーダーのユーザーは`H`キーで見出し間を移動しながらページの構造を素早く把握できます。WCAG 2.4.6（見出し及びラベル）では、見出しがコンテンツの目的を記述していることを求めており、チャットページの「あびやチャット」のようなページタイトルの明示は基本的かつ重要な修正です📝

### ARIA属性の追加

次に、スクリーンリーダーへの情報伝達を強化するARIA（Accessible Rich Internet Applications）属性が追加されました♿

チャットメッセージの一覧表示領域には`role="log"`と`aria-live="polite"`が設定されました。`role="log"`はWAI-ARIA仕様で定義されたロールで、「新しい情報が順次追加されるコンテンツ領域」であることを支援技術に伝えます。チャットアプリのメッセージ一覧はまさにこのパターンに該当します。`aria-live="polite"`は、この領域の内容が変化した際にスクリーンリーダーが**現在の読み上げを中断せずに**、読み上げが完了した後に変更内容を通知するよう指示する属性です。チャットメッセージは頻繁に追加されますが、ユーザーが入力中に読み上げを割り込まれると操作が中断されてしまうため、`polite`という値が適切です📢

一方、SignalRの接続状態（接続中・接続済み・切断など）を表示する`FluentBadge`コンポーネントには`role="status"`と`aria-live="polite"`が設定されました。ソースコード上では`<FluentBadge Appearance="Appearance.Accent" role="status" aria-live="polite">SignalR接続中...</FluentBadge>`のように記述されています。接続状態の変化はユーザーに通知すべき情報ですが、チャット操作を中断するほどの緊急性はないケースが多いため、`polite`が選択されています。なお、`App.razor`のエラーUI領域には`aria-live="assertive"`が設定されており、致命的なエラー（Blazorの未処理例外など）については即座に通知される構成になっています⚡

入力フォームのFluent UIコンポーネントには`AriaLabel`属性が追加されました。たとえば、チャット入力欄の`FluentTextField`には`AriaLabel="ここにチャットで発言するコメントを入力してください"`、発言ボタンの`FluentButton`には`AriaLabel="発言するときはこのボタンを押してください"`、AIキャラクターへの話しかけボタンには`AriaLabel="ほのかさんに話しかける"`がそれぞれ設定されています。Fluent UI Blazorの`AriaLabel`プロパティは内部的にHTML要素の`aria-label`属性にマッピングされるため、スクリーンリーダーは各入力欄やボタンの用途を正確に音声で伝えられるようになります🔗

さらに、AIキャラクターのアイコンとして使用されている絵文字（💁‍♀️ ほのか、👩‍🏫 みずき）には`role="img"`と`aria-label`が追加されました。コードでは`<span style="font-size:48px;" role="img" aria-label="ほのか">💁‍♀️</span>`のように記述されており、装飾的な絵文字がスクリーンリーダーによって「ほのか」「みずき」として読み上げられるようになっています🎭

### フォーム・インタラクションの改善

`<input>`要素と`<label>`要素の紐付けは、Webアクセシビリティにおける最も基本的な対応の一つです。Fluent UI Blazorの`FluentTextField`コンポーネントは`Label`プロパティを通じてラベルと入力欄を内部的に紐付ける機能を持っています。チャット入力欄には`Label="コメント入力"`が設定されており、コンポーネント内部で`<label>`要素が自動生成されます。さらに、`AriaLabel`プロパティによる明示的なアクセシブル名の指定（`AriaLabel="ここにチャットで発言するコメントを入力してください"`）が追加されたことで、スクリーンリーダーはより具体的な説明を読み上げられるようになりました⌨️

フォーカス管理については、メッセージ送信後に入力欄へフォーカスが自動的に戻る処理が追加されました。チャットアプリでは「メッセージを入力→送信→次のメッセージを入力」というサイクルが繰り返されるため、送信後にフォーカスが入力欄から外れてしまうと、ユーザーは毎回Tabキーで入力欄まで戻る必要があり、操作の流れが大きく損なわれます。特にスクリーンリーダーのユーザーにとっては、フォーカスがどこに移動したかを音声で確認しながらTabキーを押す必要があるため、フォーカスの不要な移動は操作テンポを著しく悪化させます。実際のコードでは`FluentTextField`への`@ref`参照を保持し、送信処理後にフォーカスを戻す実装が行われています🔄

WCAG 2.1.1（キーボード）は「すべての機能がキーボードインターフェースを通じて操作可能であること」を求めており、今回の修正によりマウスを使わずともチャットの全機能（メッセージ入力、送信、AIキャラクターへの話しかけ、メッセージ一覧の確認）がキーボードのみで完結する状態が確保されました。ソースコード上では、Enterキーによる送信操作を`IKeyCodeService`を通じて`OnKeyDownAsync`ハンドラで処理しており、Fluent UIの`FluentKeyCodeProvider`と連携することでキーボード操作の一貫性を保っています✅

### フォーカスの可視性

フォーカスインジケーターのスタイルについて、Fluent UI Blazorはデザイントークンを通じてフォーカス時のアウトラインスタイルを内部的に管理しています。Fluent UI Blazorコンポーネントのフォーカスインジケーターは、コンポーネントのシャドウDOM内部でスタイルが適用されるため、外部CSSでの明示的な設定なしにフォーカスの可視化が実現されています👁️

WCAG 2.1までは、フォーカスの可視化に関する達成基準は2.4.7（フォーカスの可視化、レベルAA）のみでした。WCAG 2.2では新たに**2.4.11 Focus Not Obscured (Minimum)**（レベルAA）と**2.4.12 Focus Not Obscured (Enhanced)**（レベルAAA）が追加されています。2.4.11は、フォーカスされた要素が他のコンテンツ（固定ヘッダー、モーダルダイアログ、Cookie同意バナーなど）によって**完全に**隠されないことを求める基準です。また、2.4.13 Focus Appearance（レベルAAA）では、フォーカスインジケーターのサイズやコントラスト比まで具体的な数値基準が定められています📏

GitHub CopilotはこれらのWCAG 2.2の新基準を把握しており、Fluent UIコンポーネントが提供するフォーカスインジケーターが他の要素に隠されないよう、レイアウト構造やz-indexの設定を確認・調整しています。Fluent UIのデザインシステムでは`:focus-visible`疑似クラスに相当するフォーカス管理が内部的に実装されており、キーボード操作時にのみフォーカスインジケーターを表示する（マウスクリック時には表示しない）挙動を実現しています。これにより、キーボードユーザーの利便性とマウスユーザーの視覚的なノイズ軽減が両立されています🎨

:::message
GitHub Copilotが**WCAG 2.2で新たに追加された基準**（フォーカスの不遮蔽など）も正確に把握しており、Fluent UIのデザイントークンによるフォーカス管理と組み合わせて的確に対応していた点は注目に値します📝
:::

## GitHub Copilotの対応だけで到達した地点

GitHub Copilotによる修正の結果、ランドマークロールの明示的設定によるセマンティクス構造の強化、`AriaLabel`・`aria-live`・`role`属性の追加によるスクリーンリーダーへの情報伝達、キーボードナビゲーションの最適化、フォーカス管理の改善、フォーム要素のラベル強化といった、WCAG 2.2 AAの主要な達成基準に関わる領域が大幅に改善されました📈

とはいえ、これはあくまでコードレベルの修正が適切に行われた段階です。修正が実際のブラウザ上でWCAG 2.2 AAの基準を満たしているかどうかは、自動検査ツールによる客観的な検証が必要です。次のステップで、Lighthouseを使った検証に進みます🔍

# Lighthouseによる自動検査

## Lighthouseとは

Lighthouseは、Googleが開発したオープンソースのWeb品質監査ツールです。Chrome DevToolsに統合されており、パフォーマンス、アクセシビリティ、ベストプラクティス、SEOといった複数のカテゴリでWebページを自動的に監査し、スコアと改善提案を提示します🔎

アクセシビリティの監査においては、内部的にDeque Systems社が開発した**axe-core**エンジンを使用しています。axe-coreはWCAGの達成基準に基づくルールセットを定義しており、DOMの構造やCSSのスタイル、ARIA属性の有無と整合性などを機械的にチェックします。Lighthouseのアクセシビリティスコアは、これらのルールに対する合格・不合格の重み付き集計として算出されます📊

DevToolsを`F12`で開き、「Lighthouse」タブからカテゴリ「Accessibility」を選択して「Analyze page load」を実行することで監査が開始されます。なお、Microsoft EdgeもChromiumベースであるため、同様の手順でLighthouse監査を実行できます🌐

## 検査結果と修正

GitHub Copilotによる修正を適用した状態でLighthouseのアクセシビリティ監査を実行したところ、**ほぼすべての項目がパス**していましたが、**1箇所だけ**指摘が残りました⚠️

:::message alert
**Background and foreground colors do not have a sufficient contrast ratio.**
（背景色と前景色に十分なコントラスト比がありません）
:::

この指摘はWCAG 1.4.3（コントラスト（最低限））に該当するものです。WCAG 2.2 AAでは、通常サイズのテキスト（18pt未満、または14pt未満で太字でないテキスト）に対して**4.5:1以上**のコントラスト比が、大きなテキスト（18pt以上、または14pt以上で太字のテキスト）に対して**3:1以上**のコントラスト比が求められます。コントラスト比は前景色（テキスト色）と背景色の相対輝度から算出される値で、1:1が同一色（差なし）、21:1が黒と白（最大差）です📏

Lighthouseが指摘した箇所はこの4.5:1の基準を満たしていませんでした。GitHub Copilotによる初期修正ではHTMLの構造やARIA属性に重点が置かれており、既存のCSSカラースキームの検証までは行われていなかったことがわかります🧐

この指摘をそのままGitHub Copilotにフィードバックしました💬

```
Lighthouseで「Background and foreground colors do not have a sufficient contrast ratio」
と指摘されている箇所があります。WCAG 2.2 AAのコントラスト比4.5:1を満たすように修正してください。
```

GitHub Copilotは指摘箇所を特定し、CSSカラーを調整してコントラスト比が4.5:1以上になるよう修正しました。コントラスト比が基準を満たしているかの確認には、Chrome DevToolsの色選択パネル（カラーピッカーを開くとコントラスト比が表示される）、[WebAIM Contrast Checker](https://webaim.org/resources/contrastchecker/)（Webベースの確認ツール）、Edge DevToolsのアクセシビリティパネルなどが利用できます🎨

コントラスト比の修正後、再度Lighthouseを実行したところ、**アクセシビリティの自動検査項目はすべてパス**しました🎉

# 今回の対応による効果の客観的考察

ここからは、GitHub Copilotによるアクセシビリティ対応が実際にどの程度の効果をもたらしたのかを、WCAG 2.2 AAの達成基準体系や、自動検査と手動検査それぞれのカバー範囲、さらにリアルタイムチャットアプリ固有の課題といった複数の観点から客観的に分析します📊

## WCAG 2.2 AA達成基準に対するカバレッジ

WCAG 2.2 AAには全部で**55の達成基準**（レベルA: 30 + レベルAA: 25）が定義されています。これらはすべてのWebコンテンツに一律に適用されるわけではなく、コンテンツの性質に応じて「該当する」基準と「該当しない」基準があります📏

たとえば、1.2系の達成基準（収録済み音声のみ、収録済み映像のみ、キャプション、音声解説など）は、音声や動画コンテンツに対する基準であるため、テキストチャットのみのアプリケーションには該当しません。同様に、1.4.2（音声の制御）も今回のアプリには適用外です。このように該当しない基準を除外すると、実際に対応が求められる基準の数はアプリケーション毎に異なります🧮

今回の対応は、WCAGの4原則すべてに寄与しています。第1原則「知覚可能」に対しては、ARIA属性の追加とロールの明示設定により1.1.1（非テキストコンテンツ）と1.3.1（情報及び関係性）を、CSSカラーの調整により1.4.3（コントラスト（最低限））を対応しました。1.3.1は「情報、構造、及び関係性がプログラムによる解釈が可能であるか、またはテキストで提供されている」ことを求める基準であり、Fluent UIコンポーネントへのランドマークロールの明示的な付与やAIキャラクターの絵文字への`role="img"`設定はまさにこの基準の直接的な対応に当たります📐

第2原則「操作可能」に対しては、キーボード操作の完全対応で2.1.1（キーボード）、フォーカス移動の最適化で2.4.3（フォーカス順序）、見出しとラベルの追加で2.4.6（見出し及びラベル）、Fluent UIのデザイントークンによるフォーカスインジケーターで2.4.7（フォーカスの可視化）、レイアウト構造の確認で2.4.11（フォーカスの不遮蔽）にそれぞれ対応しています。特に2.4.11はWCAG 2.2で新設された基準であり、GitHub CopilotがWCAG 2.2の変更点を正確に反映していることを示しています⌨️

第3原則「理解可能」については、`FluentTextField`の`Label`プロパティによるラベル設定と`AriaLabel`による詳細なアクセシブル名の追加で3.3.2（ラベル又は説明）を対応しました。第4原則「堅牢」については、`role="log"`や`aria-live`の適切な設定で4.1.2（名前・役割・値）を対応しています。4.1.2はカスタムUIコンポーネントに対して特に重要な基準で、Fluent UI Blazorコンポーネントの標準的なフォーム要素であれば暗黙的に満たされますが、チャットメッセージ一覧のようなカスタム領域やAIキャラクターの絵文字アイコンではARIAロールの明示的な設定が必要になります🏗️

## 自動検査と手動検査のカバー範囲

アクセシビリティの検査手法は**自動検査**と**手動検査**に大別されます。両者は補完関係にあり、どちらか一方だけでは十分なアクセシビリティ品質を担保できません🔬

自動検査ツール（Lighthouse、axe-core、pa11y、WAVE等）がカバーできるのは、アクセシビリティ問題全体の**約30〜40%**と言われています。これはGovA11y（米国政府のアクセシビリティプロジェクト）やDeque Systems社の調査に基づく数値です。自動検査で検出可能なのは、コントラスト比の不足、`alt`属性の欠落、`<label>`と`<input>`の未紐付け、ランドマーク要素の不在、見出し階層の不整合といった、DOMやCSSの状態から機械的に判定できる問題に限られます📋

一方、残りの60〜70%は人間による手動検査でしか確認できません。たとえば、`alt`属性に値が設定されているかどうかは自動検査で検出できますが、その値が画像の内容を適切に伝えているかどうかは人間の判断が必要です。「画像」「image.png」「写真」のような不適切な代替テキストは、自動検査では検出されません。同様に、`aria-live`領域に通知が設定されていても、その通知タイミングがユーザーの操作フローにおいて自然かどうか、読み上げの優先度が適切かどうかは、実際にスクリーンリーダーを使って操作しなければ判断できません🧑‍🦯

:::message
**自動検査のパス ≠ 完全なアクセシビリティ達成**です。自動検査は「機械的に検出可能な問題がゼロである」ことを意味するに過ぎず、ユーザー体験としてのアクセシビリティ品質は手動検査で担保する必要があります🔎
:::

## チャットアプリ固有の考慮事項

リアルタイムチャットアプリには、静的なWebページやフォーム主体のWebアプリケーションとは異なる、固有のアクセシビリティ課題があります🗨️

最も顕著な課題は**動的コンテンツの通知制御**です。新着メッセージの通知には`aria-live="polite"`が設定されていますが、`polite`はスクリーンリーダーが現在の読み上げを終えてから変更内容を通知する設定です。1対1のチャットであれば問題になりにくいですが、グループチャットで複数ユーザーが同時に投稿した場合、スクリーンリーダーが未読み上げのメッセージをキューに溜め込み、順次読み上げようとする可能性があります。この間にユーザーが新しいメッセージを入力しようとすると、読み上げと入力操作が干渉しあう状況が生じ得ます。高頻度な更新が想定される場合は、`aria-relevant`属性で通知対象を制限する（たとえば`aria-relevant="additions"`で追加のみを通知する）、あるいはDebounce処理を入れて通知頻度を制御するなどの追加対応が考えられます💬

接続状態の通知に関しても留意点があります。現在の実装では接続状態の`FluentBadge`に`aria-live="polite"`が設定されていますが、SignalRの接続が不安定なネットワーク環境では、切断と再接続が短時間に繰り返される場合があり、その都度通知が発生するとスクリーンリーダーの出力がノイズだらけになります。`App.razor`のエラーUI領域には`aria-live="assertive"`が設定されているため、致命的な接続エラーは即時通知されますが、一時的な接続変動に対してはDebounceやThrottleを適用し、一定時間内の状態変化をバッファリングしてから通知する設計が有効です🔗

チャット履歴のスクロールについても検討が必要です。`role="log"`を持つ要素にメッセージが蓄積されていくと、DOMノードの数が増加し、スクリーンリーダーがアクセシビリティツリーを再構築するコストが上昇します。数百〜数千件のメッセージが蓄積された場合、仮想スクロール（表示領域にあるメッセージのみをDOMにレンダリングする手法）を導入し、DOMノード数を一定に保つことでパフォーマンスとアクセシビリティの両立を図る必要があるかもしれません📜

## 対応工数の評価

今回の対応フローを振り返ると、GitHub Copilotへのプロンプトは計2回（初期対応1回 + コントラスト比修正のフィードバック1回）、Lighthouseの実行は計2回（初回検査 + 再検査）で、自動検査のパスに到達しています⏱️

従来のアクセシビリティ対応フローでは、まずWCAG 2.2 AAの55の達成基準を確認し、アプリケーションに該当する基準を洗い出し、各基準に対して現状のコードを評価し、不適合箇所を特定し、修正方針を決定し、コードを修正し、テストするというサイクルを繰り返す必要がありました。このプロセスには、WCAGの達成基準に関する専門知識と、HTML/CSS/ARIAの実装パターンに関する実務経験の両方が求められます🔧

今回は**プロンプトベースの対話2回で同等の修正に到達**しました。もちろん、GitHub Copilotの出力を無検証で受け入れるのではなく、修正内容が妥当かどうかを確認する作業は必要です。しかし、「何を修正すべきかを人間がゼロから特定する」コストが「提案された修正内容をレビューする」コストに置き換わったことで、アクセシビリティに関する深い専門知識がないエンジニアでも既存アプリの対応に着手できるようになったと言えます📝

## 今後必要な検証

自動検査をパスした現時点から、アクセシビリティ品質をさらに高めるためには、手動検査による体験の検証が不可欠です📋

まず優先すべきは、NVDAやナレーターなどのスクリーンリーダーを使った実操作テストです。具体的には、アプリを起動してからログイン（ASP.NET Core Identityによる認証）し、メッセージを送信し、他のユーザーやAIキャラクターからのメッセージを受信するという一連のフロー全体を、画面を見ずに音声のみで完結できるかを確認します。ARIA属性がコード上で正しく設定されていても、スクリーンリーダーの実装によって読み上げの挙動が異なる場合があるため、NVDA（Windows / 無料）、ナレーター（Windows標準）、VoiceOver（macOS / iOS標準）の少なくとも2種類以上での確認が望ましいです🗣️

次に、キーボードのみでの操作テストとして、Tabキーによるフォーカス移動の順序が論理的であるか、Enterキーによる送信操作が確実に動作するか、Escapeキーやその他のキー操作が期待通りの挙動をするかを検証します。本アプリケーションでは`IKeyCodeService`と`FluentKeyCodeProvider`を通じたキーボードイベントハンドリングが実装されており、Enterキーによるメッセージ送信がカスタムハンドラで処理されています。Blazor Interactive Autoモードでは、Server→WebAssembly切り替え時にキーボードイベントリスナーの再登録が正しく行われるかにも注意が必要です⌨️

モバイル環境においては、iOSのVoiceOverやAndroidのTalkBackを使い、タッチ操作とスクリーンリーダーを併用した場合の品質を確認する必要があります。タッチスクリーンでのスクリーンリーダー操作は、デスクトップとは異なるジェスチャー体系を持つため、デスクトップで問題なく操作できたとしてもモバイルで問題が発生するケースがあります📱

最後に、SignalR接続の断絶・再接続時のエラーハンドリングです。ネットワークが不安定な環境でアプリを使用した場合に、接続状態の変化がスクリーンリーダーに適切に伝わるか、切断中にメッセージを送信しようとした場合のエラーメッセージがアクセシブルであるかを確認する必要があります🔄

# まとめ

今回のシリーズ全体を振り返ると、アクセシビリティ対応は以下のような段階的なアプローチで進められることがわかります🧭

| ステップ | 内容 | 対応記事 |
|---------|------|---------|
| 1️⃣ | 概念を理解する | [Webアクセシビリティは"もしも"に備える設計](https://qiita.com/tomokusaba/items/9b88360daa685accb33a) |
| 2️⃣ | フレームワークの力を借りる | [Fluent UI Blazorで実現するWebアクセシビリティ対応](https://zenn.dev/tomokusaba/articles/fce3b0419c9568) |
| 3️⃣ | CI/CDで品質を担保する | [WebアクセシビリティをCI/CDで担保する](https://zenn.dev/tomokusaba/articles/035e696351e16d) |
| 4️⃣ | 実アプリで実践する（本記事） | GitHub Copilotで既存アプリを対応 |

第1回で概念と法的背景を理解し、第2回でFluent UIのようなフレームワーク自体に組み込まれたアクセシビリティ対応を学び、第3回でCI/CDパイプラインによる自動検査の仕組みを構築し、そして今回の第4回で既存アプリに対する実践的な対応を試みました。このシリーズを通じて見えてきたのは、アクセシビリティ対応は「知識の習得」「フレームワークの活用」「自動化による品質担保」「実アプリでの実践」という4つの層が相互に補完しあうアプローチであるということです📚

GitHub Copilotを活用したアクセシビリティ対応について総括すると、「WCAG 2.2 AAに対応してください」というシンプルなプロンプトだけで、ランドマークロールの明示的設定、ARIA属性（`AriaLabel`・`aria-live`・`role`）の追加、キーボードナビゲーションの確保、フォーカス管理の最適化、フォーム要素のラベル強化といった広範な修正が得られました。Fluent UI Blazorが提供する基本的なアクセシビリティ機能の上に、アプリケーション固有のコンテキストに応じた対応を積み上げる形で改善が実現されています。Lighthouseで検出されたコントラスト比の問題も、指摘内容をフィードバックするだけでピンポイントに修正でき、計2回のプロンプトで自動検査のパスに到達しています🎯

一方で、自動検査がカバーできるのはアクセシビリティ問題全体の30〜40%に過ぎないという限界を認識しておく必要があります。残りの60〜70%はスクリーンリーダーによる実操作テスト、キーボードのみでのナビゲーション確認、代替テキストの内容妥当性の評価など、人間の手と耳と目による検証が不可欠です。特にリアルタイムチャットのような動的アプリケーションでは、`aria-live`による通知の頻度制御やSignalR接続断時のエラーハンドリングなど、静的なWebページにはない固有の課題が残っています🧑‍🦯

GitHub Copilotはアクセシビリティ対応の**開始地点を引き上げる**ツールとして有効です。WCAGの達成基準に関する専門知識がなくても、基本的な対応をコードに反映できるようになることで、「何から手をつければよいかわからない」というアクセシビリティ対応の最大の障壁を大きく下げてくれます。その上で、自動検査ツールと手動検査を組み合わせて品質を高めていくという段階的なアプローチが、現実的かつ効果的な方法論であると言えるでしょう🌍

# 参考リンク

- [BlazorServerChat2](https://github.com/tomokusaba/BlazorServerChat2) ― 本記事の題材リポジトリ 💬
- [WCAG 2.2](https://www.w3.org/TR/WCAG22/) ― W3C 📖
- [Chrome Lighthouse](https://developer.chrome.com/docs/lighthouse/) ― Google 🔧
- [ASP.NET Core SignalR](https://learn.microsoft.com/ja-jp/aspnet/core/signalr/introduction) ― Microsoft Learn 💬
- [Blazor のアクセシビリティ](https://learn.microsoft.com/ja-jp/aspnet/core/blazor/components/accessibility) ― Microsoft Learn ♿
- [Fluent UI Blazor](https://www.fluentui-blazor.net/) ― Microsoft 🎨
- [GitHub Copilot](https://github.com/features/copilot) ― GitHub 🤖
- [WebAIM Contrast Checker](https://webaim.org/resources/contrastchecker/) ― WebAIM 🧪
- [WAI-ARIA 1.2](https://www.w3.org/TR/wai-aria-1.2/) ― W3C 🏗️
- [axe-core](https://github.com/dequelabs/axe-core) ― Deque Systems 🔍

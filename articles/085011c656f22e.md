---
title: ".NET 10の概要"
emoji: "🐙"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["dotnet", "csharp"]
published: false
---

## はじめに

とうとう、.NET 10がGA（一般提供）になりました！🎉

この記事では、.NET 10の新機能について解説する前に、まず.NETとは何か、そしてよくある誤解について整理していきたいと思います。

## 🎯 .NET 10はLTS（長期サポート版）です

.NET 10は**LTS（Long Term Support）**リリースです。これは本番環境での採用を検討している方にとって重要なポイントです。

### .NETのサポートポリシー

.NETは毎年11月に新しいメジャーバージョンがリリースされますが、サポート期間は**2種類**あります：

| サポート種別 | サポート期間 | 対象バージョン |
|-------------|-------------|---------------|
| **LTS（Long Term Support）** | **3年間** | 偶数バージョン（.NET 8, 10, 12...） |
| **STS（Standard Term Support）** | **2年間** | 奇数バージョン（.NET 9, 11, 13...） |

### リリースとサポートのタイムライン

```
.NET 8   .NET 9   .NET 10   .NET 11   .NET 12
Nov 2023  Nov 2024  Nov 2025   Nov 2026   Nov 2027
  │         │         │          │          │
  ├─────────┼─────────┼──────────┼──────────┤
  │  LTS    │   STS   │   LTS    │   STS    │  LTS
  │ (3年)   │  (2年)  │  (3年)   │  (2年)   │ (3年)
```

### どちらを選ぶべき？

| 状況 | 推奨 |
|------|------|
| 🏢 本番環境・エンタープライズ | **LTS版**（.NET 10）を推奨。安定性とサポート期間を重視 |
| 🧪 新機能を試したい・開発環境 | STS版でもOK。最新機能をいち早く利用可能 |
| 🔄 .NET 8からの移行 | .NET 10への移行がおすすめ（LTS → LTS） |
| 🔄 .NET 9からの移行 | .NET 10への移行を推奨（STS → LTS、サポート期間延長） |

### .NET 10のサポート終了予定

.NET 10は**2025年11月リリース**、**2028年11月頃までサポート**される予定です。

> 📌 **ポイント**: LTSリリースを選ぶことで、頻繁なアップグレードの手間を減らしながら、セキュリティパッチや重要な修正を継続して受け取ることができます。

詳細は公式ブログ「[Announcing .NET 10](https://devblogs.microsoft.com/dotnet/announcing-dotnet-10/)」を参照してください。

## C#と.NETの違い

意外と混同されがちですが、C#と.NETは別物です。

| 用語 | 説明 |
|------|------|
| **C#** | プログラミング言語そのもの |
| **.NET** | アプリケーションプラットフォーム（ランタイム）。C#、F#、VBなど複数の言語で開発可能 |

## .NETを選ぶ理由

[公式サイト](https://dotnet.microsoft.com/ja-jp/platform/why-choose-dotnet)でも紹介されていますが、.NETには以下のような特徴があります。

### 🚀 生産性

.NETは、生産性を重視する開発者にとって究極のプラットフォームです：

- **高度な言語機能** - ジェネリック、LINQ、非同期プログラミング（async/await）
- **広範なクラスライブラリ** - 標準ライブラリだけで多くのことが実現可能
- **多言語サポート** - C#、F#、VBから選択可能
- **強力な開発ツール** - Visual Studioファミリによるシームレスな開発体験

### 🌍 あらゆるアプリ、あらゆるプラットフォーム

.NETを使用すると、あらゆるプラットフォームで動作するあらゆる種類のアプリケーションを開発できます。開発者は慣れ親しんだ環境でスキルとコードを再利用でき、アプリをより迅速に、低コストでビルドできます。

### 言語の多様性
- 🔷 C# - 最も人気のある選択肢
- 🔶 F# - 関数型プログラミング
- 🟣 Visual Basic - レガシーサポート

### クロスプラットフォーム対応

.NETは、以下のオペレーティングシステムでサポートされています：

- 🖥️ **Windows** - Windows 10/11、Windows Server
- 🍎 **macOS** - Apple Silicon（M1/M2/M3）もネイティブ対応
- 🐧 **Linux** - Ubuntu、Red Hat Enterprise Linux、Debian、Alpine等
- 📱 **モバイル** - iOS / Android（.NET MAUI経由）
- 🐳 **コンテナ** - Docker、Kubernetes

### 📦 アプリケーションモデル

.NETでは、ベースライブラリの上に構築された**アプリモデル**を使用して、さまざまな種類のアプリを迅速に構築できます。

#### 🌐 Web

**[ASP.NET Core](https://dotnet.microsoft.com/ja-jp/apps/aspnet)** を使用して、Windows、Linux、macOS、Docker向けのWebアプリとサービスを構築します。

| 技術 | 説明 | ユースケース |
|------|------|-------------|
| **ASP.NET Core MVC** | 従来のMVCパターン | 大規模Webアプリ |
| **Razor Pages** | ページベース開発 | シンプルなWebアプリ |
| **Blazor Server** | サーバーサイドUI | リアルタイムアプリ |
| **Blazor WebAssembly** | ブラウザ上で.NET実行 | SPA、オフライン対応 |
| **Minimal API** | 軽量REST API | マイクロサービス |
| **gRPC** | 高性能RPC | サービス間通信 |
| **SignalR** | リアルタイム通信 | チャット、通知 |

#### 📱 モバイル

**[.NET MAUI](https://dotnet.microsoft.com/ja-jp/apps/maui)**（Multi-platform App UI）を使用して、単一のコードベースからiOS、Android、Windows、macOS向けのネイティブモバイルアプリをビルドします。

```
┌─────────────────────────────────────┐
│         共通C#コードベース           │
│  （ビジネスロジック、データアクセス）  │
├─────────┬─────────┬─────────┬───────┤
│   iOS   │ Android │ Windows │ macOS │
│  ネイティブUI  │ ネイティブUI │ ネイティブUI │ ネイティブUI │
└─────────┴─────────┴─────────┴───────┘
```

#### 🖥️ デスクトップ

Windows および macOS 用のネイティブデスクトップアプリを作成できます：

| 技術 | プラットフォーム | 特徴 |
|------|----------------|------|
| **WPF** | Windows | 高度なUI、データバインディング |
| **WinForms** | Windows | 迅速な開発、レガシー対応 |
| **WinUI 3** | Windows 11/10 | 最新のFluent Design |
| **.NET MAUI** | Windows/macOS | クロスプラットフォーム |
| **Avalonia UI** | Windows/macOS/Linux | OSSクロスプラットフォーム |

#### 🤖 AI・機械学習

**[ML.NET](https://dotnet.microsoft.com/ja-jp/apps/ai)** や **Semantic Kernel** を使用して、C#でAIアプリケーションを構築：

- 🧠 **ML.NET** - .NETネイティブの機械学習フレームワーク
- 🔮 **Semantic Kernel** - LLM（大規模言語モデル）統合
- 🤖 **Azure OpenAI** - GPT-4等との連携
- 📊 **TensorFlow.NET** - TensorFlowの.NETバインディング

#### ☁️ クラウド・マイクロサービス

- **Azure Functions** - サーバーレスコンピューティング
- **Azure Container Apps** - コンテナ化されたマイクロサービス
- **.NET Aspire** - クラウドネイティブ開発スタック
- **Dapr** - 分散アプリケーションランタイム

#### 🎮 ゲーム

- **Unity** - 世界で最も人気のあるゲームエンジン（C#使用）
- **Godot** - オープンソースゲームエンジン（C#サポート）
- **MonoGame** - クロスプラットフォーム2Dゲームフレームワーク

#### 🔌 IoT（モノのインターネット）

**[.NET IoT Libraries](https://dotnet.microsoft.com/ja-jp/apps/iot)** を使用して、Raspberry Pi等のデバイス向けアプリを構築：

- 📡 GPIO、I2C、SPI、PWM等のハードウェアアクセス
- 🌡️ センサー、ディスプレイ、モーター制御
- 🏠 スマートホーム、産業用IoTアプリケーション

#### ⌨️ コンソール・CLI

- シンプルなコマンドラインツール
- バッチ処理、自動化スクリプト
- `System.CommandLine`による本格的なCLI構築

### 📚 ライブラリエコシステム

.NETには、コレクション、ネットワーク、暗号化、機械学習まで、標準ライブラリとAPIのセットが含まれています。

- 📦 **[NuGet](https://www.nuget.org/)** - .NETのパッケージマネージャー
- 🔢 **400,000以上**のパッケージが利用可能
- 🏢 Microsoft公式パッケージから、コミュニティ製まで豊富

### 開発ツール
- Visual Studio
- Visual Studio Code
- .NET CLI
- JetBrains Rider

### オープンソース

[.NET Foundation](https://dotnetfoundation.org/)は、革新的で商業に適したオープンソースの.NETエコシステムをサポートする独立した非営利団体です。

- 📊 **100,000件以上**のコントリビューション（Microsoft以外の3,700社以上の開発者から）
- 🏢 **Technical Steering Groupメンバー**：Google、JetBrains、Red Hat、Samsung、Unityが.NETプラットフォームの未来を導いています

### 💖 開発者に愛されている

.NETは最新の革新的なオープンソース開発プラットフォームであり、開発者に愛されています。

- 🏆 [Stack Overflow Developer Survey](https://insights.stackoverflow.com/survey/2021#section-most-loved-dreaded-and-wanted-other-frameworks-and-libraries)で**2019年、2020年、2021年と3年連続で「最も愛されているフレームワーク」第1位**にランクインした実績があり、現在も高い評価を維持しています

### 🌐 大規模なエコシステム

- 👥 世界中に**500万人以上**の.NET開発者
- 📦 [NuGetパッケージマネージャー](https://www.nuget.org/)や[Visual Studio Marketplace](https://marketplace.visualstudio.com/)から豊富なライブラリを利用可能
- 🤝 コミュニティ、MVP、大規模なサポート組織から技術的な課題に対する回答が得られる

## .NETにまつわるよくある誤解

### ❌ 誤解1：「.NETはWindowsでしか動かない」

**事実：完全にクロスプラットフォームです！** ✅

これは最も多い誤解の一つです。確かに昔の「.NET Framework」はWindows専用でしたが、2016年に登場した「.NET Core」以降、.NETは完全なクロスプラットフォーム対応となりました。

現在の.NET（.NET 5以降、統合されて単に「.NET」と呼ばれる）は：
- Linux上で本番運用されているWebアプリケーションが多数存在
- macOSでの開発が完全にサポート
- Dockerコンテナでの運用も一般的
- AWS、Google Cloud、Azureなど主要クラウドすべてで動作

### ❌ 誤解2：「.NETはMicrosoft製品でしか使えない」

**事実：オープンソースであり、どこでも動きます！** ✅

.NETはMITライセンスで公開されているオープンソースプロジェクトです。AWSのLambda、Google CloudのCloud Run、さらにはRaspberry Piでも動作します。

しかも、Technical Steering GroupにはMicrosoft以外にも**Google、JetBrains、Red Hat、Samsung、Unity**が参画しており、.NETの未来を共に導いています。

### ❌ 誤解3：「.NETは重くて遅い」

**事実：現代の.NETは非常に高速です！** ✅

.NETは高速です。**非常に**高速です。これにより、アプリケーションの応答時間が短縮され、コンピューティング電力の需要を抑えることができます。

[TechEmpower Round 21](https://www.techempower.com/benchmarks/#section=data-r21&hw=ph&test=plaintext)のベンチマークでは：

| フレームワーク | 1秒あたりのリクエスト処理数 |
|---------------|---------------------------|
| **.NET** | **約700万件** 🚀 |
| Java Servlet | 約220万件 |
| Node.js | 約60万件 |

なんと**Node.jsの約12倍**、**Javaの約3倍**の処理能力です！

この高速性を支える技術：
- ⚡ JITコンパイラの最適化
- 🧠 `Span<T>`や`Memory<T>`などのゼロアロケーションAPI
- 🔧 AOT（Ahead-of-Time）コンパイル
- 📈 継続的なパフォーマンス改善

### ❌ 誤解4：「C#は古い言語」

**事実：C#は常に進化し続けています！** ✅

C#は毎年のように新機能が追加される、非常にアクティブに開発されている言語です：

| バージョン | 年 | 主な機能 |
|-----------|-----|---------|
| C# 2.0 | 2005 | ジェネリクス |
| C# 3.0 | 2007 | LINQ |
| C# 5.0 | 2012 | async/await |
| C# 6.0 | 2015 | catch/finally内でのawait |
| C# 9.0 | 2020 | record型 |
| C# 10.0 | 2021 | global using |
| C# 11.0 | 2022 | raw string literals |
| C# 12.0 | 2023 | プライマリコンストラクタ |
| C# 13.0 | 2024 | params collections |
| C# 14.0 | 2025 | 拡張メンバー（extension members） |

## 各クラウドでの.NET対応

.NETは主要なクラウドプロバイダーすべてで動作します：

- ☁️ **Azure** - 当然ながらファーストクラスサポート
- 🟠 **AWS** - Lambda、ECS、EKSなどで動作
- 🔵 **Google Cloud** - Cloud Run、GKEなどで動作

詳細については、山田顕人さんの発表「[各クラウドサービスにおける.NETの対応と見解](https://speakerdeck.com/ymd65536/ge-kuraudosabisuniokeru-dot-netnodui-ying-tojian-jie)」も参考になります。

## 🔥 パフォーマンス改善への徹底したこだわり

.NETの大きな特徴の一つは、**毎年のリリースで継続的にパフォーマンスが改善される**ことです。

### 毎年恒例のパフォーマンス改善ブログ

MicrosoftのStephen Toub氏は、毎年「[Performance Improvements in .NET](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-10/)」というブログ記事を公開しています。

このブログの特徴：
- 📜 **スクロールバーに注目！** - 膨大な量の改善点が詳細に記載されている
- 📊 ベンチマークコード付きで改善を実証
- 🔬 JIT、ランタイム、ライブラリすべてのレイヤーでの最適化を解説
- 📅 .NET Core 2.0から毎年継続して公開

> .NET 10のパフォーマンスストーリーは、一つの魔法のようなアイデアではありません。何兆回も実行される操作から、ナノ秒単位、数十バイト単位で慎重に削り取っていく、数百から数千の的を絞った最適化が積み重なって、変革的なものになるのです。
> — Stephen Toub, [Performance Improvements in .NET 10](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-10/)

### パフォーマンス改善がもたらすメリット

💡 **パフォーマンス改善とは何を意味するのか？**

1. **バージョンアップするだけで速くなる** 🚀
   - 毎年、.NETバージョンをアップデートするだけで、コードを何も変更しなくても（破壊的変更があればそれに対応さえすれば）確実に速くなります

2. **コスト削減に直結** 💰
   - 現代では、速度はコンピューティングリソースのサイジングに直結する問題
   - 最適化が進んでいればそれだけクラウド課金が少なくて済む可能性がある

### .NET 10のパフォーマンス改善の典型例

.NET Conf 2025 Keynoteより、.NET minimal APIsのパフォーマンス比較（TechEmpower Benchmarks、Intel Gold 56 logical cores Linux環境）：

| 指標 | .NET 8 | .NET 10 | 改善率 |
|------|--------|---------|--------|
| **Requests/Sec** | 1,500,298 | 1,722,294 | **15% 高速化** 🚀 |
| **Max Working Set (MB)** | 1,643 | 115 | **93% メモリ削減** 📉 |

Source: [aka.ms/aspnet/benchmarks](https://aka.ms/aspnet/benchmarks)

### .NET 10での主な最適化領域

[Performance Improvements in .NET 10](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-10/)で解説されている主な最適化領域：

| 領域 | 主な改善内容 |
|------|-------------|
| **JIT** | 抽象化のペナルティ削減、境界チェック削除、インライン化強化、定数畳み込み |
| **Native AOT** | 事前コンパイル最適化、サイズ削減 |
| **VM** | ランタイム効率化、メモリ管理改善 |
| **Threading** | スレッドプール最適化、Task.WhenAll改善 |
| **Collections** | LINQ最適化、FrozenDictionary改善、列挙処理高速化 |
| **I/O** | 圧縮ライブラリ更新（zlib-ng 2.2.5）、ストリーム処理最適化 |
| **Networking** | HttpClient最適化、Uri処理改善 |
| **JSON** | System.Text.Json最適化、新API追加 |
| **Regex** | 正規表現エンジン最適化 |
| **Cryptography** | 暗号化処理高速化 |

### 「抽象化のペナルティ」を削減

従来、.NETには「抽象化のペナルティ」がありました。インターフェース、イテレータ、デリゲートなどの高レベル言語機能を使用する際に発生する余分なアロケーションや間接参照です。

しかし、毎年JITコンパイラが改善され、抽象化のレイヤーを最適化することで、開発者はシンプルなコードを書きながらも優れたパフォーマンスを得られるようになっています。

```csharp
// こういった慣用的なC#コード（インターフェース、foreach、ラムダを使用）が
// 手動で最適化したコードに近い速度で動作するようになっている
var result = items
    .Where(x => x.IsActive)
    .Select(x => x.Value)
    .Sum();
```

## .NETの信頼性と安全性

.NETプラットフォームはMicrosoftにより正式にサポートされており、何千もの企業と何百万人もの開発者に信頼されています。Microsoftはセキュリティを非常に重視しており、脅威が検出されると迅速に更新プログラムをリリースします。

### 採用企業の例

世界中のさまざまな業界の顧客が、ビジネスを.NETに依存しています：
- 🌮 **Chipotle** - .NETを使用してカスタマーWebエクスペリエンスを強化
- 🗺️ **Geocaching** - .NET APIを使用してグローバルなスケーリングと顧客の成長を実現
- 📊 **BurnRate** - 市場投入チームの収益、需要、人員計画システムに.NETとBlazorを採用

## 🆕 .NET 10世代の主なアップデート

.NET 10では、C# 14、ランタイム、SDK、ASP.NET Coreなど、多くの領域で機能強化が行われています。

### 💎 C# 14

C# 14では、言語機能が大幅に拡張されました。主な新機能は以下の通りです：

- 🔷 拡張メンバー
- 🔷 Null条件付き割り当て
- 🔷 `nameof`でバインドされていないジェネリック型をサポート
- 🔷 `Span<T>`および`ReadOnlySpan<T>`の暗黙的な変換
- 🔷 単純なラムダパラメーターの修飾子
- 🔷 `field`キーワード（プロパティのバッキングフィールド）
- 🔷 部分イベントとコンストラクター
- 🔷 ユーザー定義複合代入演算子

#### 拡張メンバー（Extension Members）

C# 3.0から拡張メソッドがありましたが、C# 14では**拡張ブロック構文**で以下も定義できるようになりました：

- 📌 拡張メソッド
- 📌 拡張プロパティ
- 📌 静的拡張メソッド・プロパティ
- 📌 ユーザー定義演算子

```csharp
public static class Enumerable
{
    // 拡張ブロック - IEnumerable<TSource>のインスタンスメンバーとして呼び出し可能
    extension<TSource>(IEnumerable<TSource> source)
    {
        // 拡張プロパティ
        public bool IsEmpty => !source.Any();

        // 拡張メソッド
        public IEnumerable<TSource> Where(Func<TSource, bool> predicate) { /* ... */ }
    }

    // 型のみを指定した拡張ブロック - 静的メンバーとして呼び出し可能
    extension<TSource>(IEnumerable<TSource>)
    {
        // 静的拡張メソッド
        public static IEnumerable<TSource> Combine(
            IEnumerable<TSource> first, 
            IEnumerable<TSource> second) { /* ... */ }

        // 静的拡張プロパティ
        public static IEnumerable<TSource> Identity => Enumerable.Empty<TSource>();

        // ユーザー定義演算子
        public static IEnumerable<TSource> operator +(
            IEnumerable<TSource> left, 
            IEnumerable<TSource> right) => left.Concat(right);
    }
}

// 使用例
var sequence = new[] { 1, 2, 3 };
bool empty = sequence.IsEmpty;              // インスタンス拡張プロパティ
var identity = IEnumerable<int>.Identity;   // 静的拡張プロパティ
```

#### `field`キーワード

プロパティアクセサー内で`field`トークンを使用すると、明示的なバッキングフィールドを宣言せずにプロパティ本体を記述できます。

```csharp
// 以前のコード（バッキングフィールドが必要）
private string _msg;
public string Message
{
    get => _msg;
    set => _msg = value ?? throw new ArgumentNullException(nameof(value));
}

// C# 14の新構文（fieldキーワード使用）
public string Message
{
    get;
    set => field = value ?? throw new ArgumentNullException(nameof(value));
}
```

#### Null条件付き割り当て

`?.`と`?[]`演算子が代入の左側でも使用可能になりました。

```csharp
// 以前のコード
if (customer is not null)
{
    customer.Order = GetCurrentOrder();
}

// C# 14の新構文
customer?.Order = GetCurrentOrder();  // customerがnullなら何もしない
```

#### 暗黙的なスパン変換

`ReadOnlySpan<T>`、`Span<T>`、`T[]`の間で**暗黙的な型変換**が可能になりました。これにより、パフォーマンスを意識したコードがより書きやすくなります。

```csharp
// 暗黙的な変換が可能に
void ProcessData(ReadOnlySpan<byte> data) { /* ... */ }

byte[] array = new byte[100];
ProcessData(array);  // byte[] → ReadOnlySpan<byte> への暗黙変換
```

#### 修飾子を使用した単純なラムダパラメーター

型を指定せずにラムダ式パラメーターに修飾子（`scoped`、`ref`、`in`、`out`、`ref readonly`）を追加できるようになりました。

```csharp
// 型指定なしでout修飾子が使える
TryParse<int> parse = (text, out result) => int.TryParse(text, out result);
```

詳細は「[C# 14 の新機能](https://learn.microsoft.com/ja-jp/dotnet/csharp/whats-new/csharp-14)」を参照してください。

### 🔧 .NETランタイム

ランタイムレベルでの最適化が多数行われています。

| 機能 | 説明 |
|------|------|
| 🚀 **JITインライン化の改善** | より多くのメソッドがインライン化され、呼び出しオーバーヘッド削減 |
| 📦 **メソッドの非仮想化** | 仮想呼び出しを直接呼び出しに最適化 |
| 💾 **スタック割り当ての機能強化** | ヒープではなくスタックに割り当て可能なケースが増加 |
| 🔢 **AVX10.2のサポート** | 最新のSIMD命令セットに対応 |
| ⚡ **Native AOTの機能強化** | 事前コンパイルの改善、起動時間短縮 |
| 🏗️ **構造体引数のコード生成改善** | 構造体を引数に取るメソッドの効率化 |
| 🔄 **ループ反転の強化** | ループ最適化による実行速度向上 |

### 🛠️ .NET SDK

開発者体験を向上させる多くの機能が追加されました。

| 機能 | 説明 |
|------|------|
| ✅ **Microsoft Testing Platform** | `dotnet test`で新しいテストプラットフォームをサポート |
| 📋 **CLIコマンドの順序標準化** | 一貫性のあるコマンド構文 |
| 🐚 **ネイティブタブ補完** | シェルでの補完スクリプト自動生成 |
| 🐳 **コンソールアプリのコンテナ化** | コンソールアプリを簡単にコンテナイメージ化 |
| 🌐 **プラットフォーム固有ツール** | `any` RuntimeIdentifier対応 |
| ⚡ **dotnet tool exec** | ワンショットでツールを実行 |
| 📜 **dnxスクリプト** | 新しいツール実行スクリプト |
| 🔍 **--cli-schema** | CLIのイントロスペクション機能 |
| 📦 **Native AOT拡張** | 拡張ファイルベースのアプリサポート |

### 🌟 ASP.NET Core

Web開発向けの機能も大幅に強化されています。

#### Blazorの機能強化

| 機能 | 説明 |
|------|------|
| 🔄 **WebAssemblyプリロード** | 初回読み込み時間の短縮 |
| 🗑️ **自動メモリプールの削除** | メモリ管理の改善 |
| ✅ **フォーム検証の強化** | より柔軟なバリデーション |

#### その他のASP.NET Core機能

- 📄 **OpenAPIの機能強化** - API仕様の生成・管理が向上
- 🔌 **Minimal APIの機能強化** - 軽量APIの開発がさらに簡単に
- 🔍 **診断の強化** - デバッグ・トラブルシューティング機能の改善
- 🔑 **IDのパスキーサポート** - パスワードレス認証への対応

---

## 🔐 ASP.NET Core .NET 10 深掘り：パスキーのサポート

.NET 10では、**ASP.NET Core Identity を使用した Blazor Web App でパスキー認証を実装**できるようになりました。これはパスワードレス時代への大きな一歩です！🎉

### パスキーとは？

パスキーは**FIDO2/WebAuthn**標準に基づく次世代認証方式で、従来のパスワードの問題を解決します：

| 従来のパスワード | パスキー |
|-----------------|---------|
| 😓 覚える必要がある | 🔑 生体認証やPINで自動認証 |
| 🎣 フィッシングに弱い | 🛡️ フィッシング耐性あり |
| 🔄 使い回しのリスク | ✅ サイトごとに一意 |
| 💾 サーバーに秘密情報保存 | 🔐 公開鍵のみサーバー保存 |

### 実装方法は2つ

.NET 10では、パスキーを実装する方法が2つあります：

| 方法 | 対象 | 難易度 |
|------|------|--------|
| 🆕 **新規テンプレートから作成** | 新規プロジェクト | ⭐ 簡単 |
| 🔧 **既存アプリに追加** | 既存プロジェクト | ⭐⭐⭐ 複数ステップ |

---

### 🆕 方法1: 新規プロジェクトテンプレートから作成（推奨）

**最も簡単な方法**です。テンプレートにパスキーサポートが最初から含まれています！

#### 前提条件

- .NET SDK 10 以降

#### プロジェクト作成

```bash
# パスキー対応のBlazor Web Appを作成（1コマンドで完了！）
dotnet new blazor -au Individual -o BlazorWebAppPasskeys
```

このコマンドで作成されるプロジェクトには、以下が**自動的に含まれます**：

| 機能 | 説明 |
|------|------|
| ✅ **ASP.NET Core Identity** | ユーザー認証システム |
| ✅ **SQLite + Entity Framework Core** | データストレージ |
| ✅ **パスキー登録・認証エンドポイント** | WebAuthn API対応 |
| ✅ **パスキー管理UIコンポーネント** | 登録・削除・名前変更 |

#### アプリの実行

```bash
cd BlazorWebAppPasskeys
dotnet watch
```

これだけで**パスキー対応のアプリが動作します**！🎊

:::message
**重要**: 現時点では、**Blazor Web App プロジェクトテンプレートのみ**に組み込みのパスキーサポートが含まれています。
:::

---

### 🔧 方法2: 既存アプリにパスキーを追加

既存の ASP.NET Core Identity を使用した Blazor Web App にパスキーを追加する場合は、以下の手順が必要です。

#### 前提条件

- .NET 10 以降
- ASP.NET Core Identity を使用した既存の Blazor Web App

#### 手順1: Identity スキーマバージョンを更新

`Program.cs` で、パスキーをサポートする**スキーマバージョン3**を使用するように Identity を構成します：

```csharp
// Program.cs
builder.Services.AddIdentityCore<ApplicationUser>(options =>
{
    options.SignIn.RequireConfirmedAccount = true;
    options.Stores.SchemaVersion = IdentitySchemaVersions.Version3; // 🔑 パスキー対応
})
.AddEntityFrameworkStores<ApplicationDbContext>()
.AddSignInManager()
.AddDefaultTokenProviders();
```

#### 手順2: データベース移行を作成して実行

```bash
# マイグレーションの追加
dotnet ef migrations add AddPasskeySupport

# データベースに適用
dotnet ef database update
```

#### 手順3: 必要なコンポーネントを追加

公式テンプレートに基づいて、以下のファイルを `Components/Account` フォルダーに追加します：

| ファイル | 説明 |
|---------|------|
| 📄 `PasskeyInputModel.cs` | パスキー資格情報のJSONを保持するモデル |
| 📄 `PasskeyOperation.cs` | 認証アクション（作成/リクエスト）を定義 |
| 📄 `Shared/PasskeySubmit.razor` | パスキー操作を処理するコンポーネント |
| 📄 `Shared/PasskeySubmit.razor.js` | WebAuthn APIとの対話を処理 |
| 📄 `Pages/Manage/Passkeys.razor` | パスキー管理ページ |
| 📄 `Pages/Manage/RenamePasskey.razor` | パスキー名前変更ページ |

:::details 各ファイルのソースコードリンク（GitHub）
- [PasskeyInputModel.cs](https://github.com/dotnet/aspnetcore/blob/main/src/ProjectTemplates/Web.ProjectTemplates/content/BlazorWeb-CSharp/BlazorWebCSharp.1/Components/Account/PasskeyInputModel.cs)
- [PasskeyOperation.cs](https://github.com/dotnet/aspnetcore/blob/main/src/ProjectTemplates/Web.ProjectTemplates/content/BlazorWeb-CSharp/BlazorWebCSharp.1/Components/Account/PasskeyOperation.cs)
- [PasskeySubmit.razor](https://github.com/dotnet/aspnetcore/blob/main/src/ProjectTemplates/Web.ProjectTemplates/content/BlazorWeb-CSharp/BlazorWebCSharp.1/Components/Account/Shared/PasskeySubmit.razor)
- [PasskeySubmit.razor.js](https://github.com/dotnet/aspnetcore/blob/main/src/ProjectTemplates/Web.ProjectTemplates/content/BlazorWeb-CSharp/BlazorWebCSharp.1/Components/Account/Shared/PasskeySubmit.razor.js)
- [Passkeys.razor](https://github.com/dotnet/aspnetcore/blob/main/src/ProjectTemplates/Web.ProjectTemplates/content/BlazorWeb-CSharp/BlazorWebCSharp.1/Components/Account/Pages/Manage/Passkeys.razor)
- [RenamePasskey.razor](https://github.com/dotnet/aspnetcore/blob/main/src/ProjectTemplates/Web.ProjectTemplates/content/BlazorWeb-CSharp/BlazorWebCSharp.1/Components/Account/Pages/Manage/RenamePasskey.razor)
:::

#### 手順4: パスキーエンドポイントを追加

`IdentityComponentsEndpointRouteBuilderExtensions.cs` にパスキー用エンドポイントを追加し、`Program.cs` で `MapAdditionalIdentityEndpoints()` を呼び出します。

#### 手順5: JavaScript ファイルを含める

`Components/App.razor` で Blazor スクリプトの直後にパスキー用JSを追加：

```razor
<script src="_framework/blazor.web.js"></script>
<!-- 🔑 パスキー用JavaScriptを追加 -->
<script src="Components/Account/Shared/PasskeySubmit.razor.js" type="module"></script>
```

#### 手順6: ナビゲーションメニューを更新

`Components/Account/Shared/ManageNavMenu.razor` にパスキー管理へのリンクを追加：

```razor
<li class="nav-item">
    <NavLink class="nav-link" href="Account/Manage/Passkeys">Passkeys</NavLink>
</li>
```

---

### パスキーの登録とサインイン

#### 登録手順

1. 新しいアカウントを登録または既存アカウントでサインイン
2. **アカウントの管理** → **Passkeys** に移動
3. **新しいパスキーの追加** を選択
4. ブラウザのプロンプトに従ってデバイスの認証器でパスキーを作成

#### サインイン手順

1. ログインページでメールアドレスを入力
2. **パスキーを使用してログイン** を選択
3. ブラウザのプロンプトに従ってパスキーで認証

:::message
パスキーは**Windows Hello**、**Touch ID**、**Face ID**、**YubiKey**などの認証器で利用できます。パスキーオートフィル（条件付きUI）にも対応しているため、メール入力フィールドを選択するだけでパスキー候補が表示されます！🚀
:::

:::message alert
**注意**: 一部のパスワードマネージャーでは `PublicKeyCredential.toJSON` メソッドが正しく実装されていない場合があり、`TypeError: Illegal invocation` エラーが発生することがあります。詳細は[公式ドキュメント](https://learn.microsoft.com/ja-jp/aspnet/core/security/authentication/passkeys/?view=aspnetcore-10.0#mitigate-publickeycredentialtojson-error-typeerror-illegal-invocation)を参照してください。
:::

詳細な実装手順は「[ASP.NET Core Blazor Web Appにパスキーを実装する](https://learn.microsoft.com/ja-jp/aspnet/core/security/authentication/passkeys/blazor?view=aspnetcore-10.0)」を参照してください。

---

## ✅ ASP.NET Core .NET 10 深掘り：モデル検証の改善

.NET 10では、モデル検証（バリデーション）が大幅に強化されました。特に**入れ子になったオブジェクトの検証**と**Source Generator ベースの検証**が注目ポイントです！🎯

### 入れ子モデル検証のサポート

.NET 9以前は実験的コンポーネントでしたが、.NET 10で**正式サポート**されました：

```csharp
public class Order
{
    [Required]
    public string OrderId { get; set; } = string.Empty;
    
    [Required]
    [ValidateObjectMembers]  // 🔄 入れ子オブジェクトも検証
    public Customer Customer { get; set; } = new();
    
    [ValidateEnumeratedItems]  // 📦 コレクション内の各アイテムも検証
    public List<OrderItem> Items { get; set; } = [];
}

public class Customer
{
    [Required]
    [EmailAddress]
    public string Email { get; set; } = string.Empty;
    
    [Required]
    [StringLength(100, MinimumLength = 2)]
    public string Name { get; set; } = string.Empty;
}

public class OrderItem
{
    [Required]
    public string ProductId { get; set; } = string.Empty;
    
    [Range(1, 100)]
    public int Quantity { get; set; }
}
```

### Source Generatorベースのモデル検証

リフレクションベースからSource Generatorベースに移行したことで、**Native AOT互換性**が向上しました：

```csharp
// Source Generatorによる検証コード生成
[GenerateValidation]  // 🏭 コンパイル時に検証コードを生成
public partial class ProductRequest
{
    [Required(ErrorMessage = "商品名は必須です")]
    [StringLength(200)]
    public string Name { get; set; } = string.Empty;
    
    [Range(0, 1_000_000, ErrorMessage = "価格は0〜1,000,000の範囲で指定してください")]
    public decimal Price { get; set; }
    
    [Url]
    public string? ImageUrl { get; set; }
}
```

### メリットの比較

| 検証方式 | リフレクション | Source Generator |
|---------|---------------|------------------|
| 🚀 **パフォーマンス** | 実行時にリフレクション | コンパイル時に生成済み |
| 💾 **メモリ使用量** | メタデータを保持 | 最小限 |
| ⚡ **Native AOT** | ❌ 非対応 | ✅ 完全対応 |
| 🔍 **デバッグ** | ブラックボックス | 生成コードを確認可能 |
| 📱 **起動時間** | 遅い | 高速 |

:::message alert
**Native AOTを使用する場合は、Source Generatorベースの検証が必須です。** リフレクションはNative AOTでは動作しません！⚠️
:::

---

## 🔌 ASP.NET Core .NET 10 深掘り：Minimal APIでのモデル検証サポート

.NET 10の最も待望されていた機能の一つが、**Minimal APIでの標準モデル検証サポート**です！これにより、コントローラーベースのWeb APIを選ぶ理由がほぼなくなりました 🎊

### 従来の課題

.NET 9以前のMinimal APIでは、モデル検証を手動で実装する必要がありました：

```csharp
// .NET 9以前：手動でのバリデーション 😓
app.MapPost("/products", (ProductRequest request) =>
{
    // 手動でバリデーションを実装...
    var context = new ValidationContext(request);
    var results = new List<ValidationResult>();
    if (!Validator.TryValidateObject(request, context, results, true))
    {
        return Results.ValidationProblem(
            results.ToDictionary(r => r.MemberNames.First(), r => new[] { r.ErrorMessage! }));
    }
    
    // ビジネスロジック...
    return Results.Ok();
});
```

### .NET 10での改善

`AddValidation()`を追加するだけで、**自動的にモデル検証が有効化**されます：

```csharp
var builder = WebApplication.CreateBuilder(args);

// 🎯 たった1行でモデル検証を有効化！
builder.Services.AddValidation();

var app = builder.Build();

// 自動的にバリデーションが適用される 🚀
app.MapPost("/products", (ProductRequest request) =>
{
    // バリデーションは自動実行済み！
    // ここに来た時点でrequestは有効
    return Results.Created($"/products/{request.Name}", request);
});

app.Run();
```

```csharp
public class ProductRequest
{
    [Required(ErrorMessage = "商品名は必須です")]
    [StringLength(100, MinimumLength = 1)]
    public string Name { get; set; } = string.Empty;
    
    [Range(1, 1_000_000)]
    public decimal Price { get; set; }
    
    [ValidateObjectMembers]  // 入れ子オブジェクトも自動検証
    public ProductDetails? Details { get; set; }
}
```

### バリデーションエラーのレスポンス

無効なリクエストの場合、**RFC 7807準拠のProblem Details形式**で自動的にエラーが返されます：

```json
{
  "type": "https://tools.ietf.org/html/rfc7807",
  "title": "One or more validation errors occurred.",
  "status": 400,
  "errors": {
    "Name": ["商品名は必須です"],
    "Price": ["The field Price must be between 1 and 1000000."]
  }
}
```

### なぜMinimal APIを選ぶべきか？

| 観点 | コントローラーベース | Minimal API |
|------|---------------------|-------------|
| 🚀 **パフォーマンス** | 良い | **より高速** |
| 📝 **コード量** | 多い | **最小限** |
| 📚 **学習コスト** | ASP.NET MVC経験者向け | **直感的** |
| 🔄 **他言語からの移行** | 違和感あり | **Express/FastAPIに近い** |
| ✅ **モデル検証** | 標準サポート | **.NET 10で標準サポート** |
| ⚡ **Native AOT** | 一部制限あり | **フル対応** |

```csharp
// Express.js風の書き方が可能 🌐
app.MapGet("/hello/{name}", (string name) => $"Hello, {name}!");

app.MapPost("/users", async (User user, UserService service) =>
{
    var created = await service.CreateAsync(user);
    return Results.Created($"/users/{created.Id}", created);
});

app.MapDelete("/users/{id:int}", async (int id, UserService service) =>
{
    await service.DeleteAsync(id);
    return Results.NoContent();
});
```

:::message
**他の言語（Node.js、Python、Go）から移行する開発者にとって、Minimal APIは非常に親しみやすい書き方です。** パフォーマンスも最高クラスなので、新規プロジェクトでは積極的にMinimal APIを選択しましょう！🎯
:::

---

## まとめ

.NET 10は**LTS（長期サポート版）**として、本番環境での採用に最適なリリースです。

### .NET 10の主なハイライト

| カテゴリ | 主な改善 |
|---------|----------|
| 🚀 **パフォーマンス** | .NET 8比で15%高速化、93%メモリ削減 |
| 💎 **C# 14** | 拡張メンバー、fieldキーワード、Null条件付き割り当て |
| 🔐 **セキュリティ** | Blazorパスキー認証サポート |
| ✅ **開発体験** | Minimal APIモデル検証、Source Generator検証 |
| ⚡ **Native AOT** | さらなる最適化と互換性向上 |

### .NETを選ぶ理由

- ✅ **クロスプラットフォーム** - Windows、macOS、Linux、コンテナで動作
- ✅ **オープンソース** - Google、JetBrains、Red Hatなども参画
- ✅ **超高パフォーマンス** - Node.jsの約12倍の処理能力
- ✅ **大規模コミュニティ** - 500万人以上の開発者
- ✅ **長期サポート** - .NET 10は2028年11月までサポート

### 次のステップ

.NET 10を始めるには：

```bash
# .NET 10 SDKをインストール後
dotnet new blazor -au Individual -o MyApp  # パスキー対応Webアプリ
dotnet new webapi -o MyApi                  # Minimal API
dotnet new console -o MyConsole             # コンソールアプリ
```

詳細は以下の公式リソースを参照してください：

- 📖 [.NET 10の新機能](https://learn.microsoft.com/ja-jp/dotnet/core/whats-new/dotnet-10/overview)
- 📖 [C# 14の新機能](https://learn.microsoft.com/ja-jp/dotnet/csharp/whats-new/csharp-14)
- 📖 [ASP.NET Core 10の新機能](https://learn.microsoft.com/ja-jp/aspnet/core/release-notes/aspnetcore-10.0)
- 📖 [Performance Improvements in .NET 10](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-10/)

.NETで素晴らしいアプリケーションを構築しましょう！🚀
